// --- ACTIVITIES ---
// These are the individual, stateless units of work that your workflow will orchestrate.
import { GoogleGenAI } from "@google/genai";
import dotenv from 'dotenv'

dotenv.config({ path: '/home/northway/Documents/hackathons/dapr-ai-hackathon/dapr-workflow/workflow-javascript/.env' })
const ai = new GoogleGenAI({
  apiKey: process.env.GEMINI_API_KEY
});
/**
 * Activity 1: Validates the incoming user query.
 * It receives the initial data sent to the workflow.
 */
const validateQuery = async (ctx, input) => {
  console.log("--- Activity: validateQuery ---");
  console.log("Received input:", JSON.stringify(input, null, 2));

  // TODO: Add query validation logic here.
  // For example, check for malicious input, check length, etc.
  const response = await ai.models.generateContent({
    model: "gemini-2.5-flash",
    contents: input.query,
    config: {
      responseMimeType: "application/json",
      responseJsonSchema: {
        "$schema": "http://json-schema.org/draft-07/schema#",
        "title": "Medical Query Validator Output",
        "description": "Defines the boolean output structure for the gatekeeper prompt, determining if a user query is valid for data retrieval.",
        "type": "object",
        "properties": {
          "is_valid_query": {
            "description": "A boolean flag that is true if the user's question is a valid request for data retrieval, and false otherwise.",
            "type": "boolean"
          },
          "reason": {
            "description": "A brief string explaining why the query is valid or invalid. This can be used for logging or for formulating a user-facing response.",
            "type": "string"
          }
        },
        "required": [
          "is_valid_query",
          "reason"
        ],
        "additionalProperties": false
      }
    }
  });

  const validationResult = {
    originalQuery: input.query,
    cypherQry: input.cypherQry,
    validityCheck: JSON.parse(response.text),
    isValid: true,
    validatedAt: new Date().toISOString(),
  };

  console.log("Returning validation result:", JSON.stringify(validationResult, null, 2));
  return validationResult;
};

/**
 * Activity 2: Generates a Cypher query from the validated user query.
 * It receives the output from the `validateQuery` activity.
 */
const generateCypher = async (ctx, input) => {
  console.log("\n--- Activity: generateCypher ---");
  console.log("Received input from previous step:", JSON.stringify(input, null, 2));

  // TODO: Add logic to call an AI model to generate the Cypher query.

  const generatedData = {
    originalQry: input.cypherQry,
    generatedAt: new Date().toISOString(),
  };

  if (input.validityCheck.is_valid_query) {
    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: input.cypherQry,
      config: {
        responseMimeType: "application/json",
        responseJsonSchema: {
          "type": "object",
          "description": "Defines the structured output for a natural language query converted to a Neo4j Cypher query.",
          "properties": {
            "query": {
              "type": "string",
              "description": "A brief, user-friendly summary of the data being requested, generated by the LLM."
            },
            "cypher": {
              "type": "string",
              "description": "The complete and syntactically correct Neo4j Cypher query string."
            }
          },
          "required": [
            "query",
            "cypher"
          ],
          "propertyOrdering": [
            "query",
            "cypher"
          ]
        }
      }
    });
    generatedData.generatedCypher = JSON.parse(response.text)
    generatedData.qryGenerated = true;

  } else {
    generatedData.qryGenerated = false;
  }

  console.log("Returning generated Cypher query:", JSON.stringify(generatedData, null, 2));
  return generatedData;
};

/**
 * Activity 3: Determine if the user's request would be more valuable if it were augmented with data from the entire database.
 * It receives the output from the `generateCypher` activity.
 */
const metaAnalysis = async (ctx, input) => {
  console.log("\n--- Activity: metaAnalysis ---");
  console.log("Received input from previous step:", JSON.stringify(input, null, 2));

  // TODO: Add logic to call an AI model to do analysis

  const metaAnalysisResult = {
    generatedAt: new Date().toISOString(),
  };
  const summarized_user_query = input.query;
  const executed_cypher = input.cypher;
  const metaAnalysisPrompt = `
  You are an advanced clinical data analyst AI. Your task is to analyze a user's data request and the Cypher query that fulfilled it. Your goal is to determine if the user's request would be more valuable if it were augmented with broader, comparative data from the entire database (i.e., data from all practitioners).\r\n\r\nYou will be given the user's goal, the specific Cypher query that was run, and the graph database schema.\r\n\r\n**Your Logic:**\r\n-   **When to suggest augmentation (\"should_augment: true\"):**\r\n    -   The query asks for counts, averages, frequencies, or patterns related to a specific practitioner (e.g., \"How many of *my* patients have diabetes?\"). This could be compared to the overall average.\r\n    -   The query asks about a practitioner's own common treatments or prescriptions (e.g., \"What medication do *I* most often prescribe for hypertension?\"). This could be compared to what all practitioners prescribe.\r\n-   **When NOT to suggest augmentation (\"should_augment: false\"):**\r\n    -   The query is about a single, specific patient's record (e.g., \"List all conditions for Jane Doe.\"). Broader data is not relevant to this specific request.\r\n    -   The query is a simple lookup that doesn't imply a need for comparison.\r\n\r\nIf you suggest augmenting the query, you must generate a new \"suggested_cypher\" that performs this broader, comparative analysis. This usually involves removing a \"MATCH\" clause that filters by a specific patient or practitioner to analyze the entire dataset.\r\n\r\nYour response MUST be a single, raw JSON object.\r\n\r\n---\r\n**1. Graph Schema:**\r\n*   **Node Labels and Properties:**\r\n    *   \"Patient\": \"id\"(STRING), \"name\"(STRING)\r\n    *   \"Encounter\": \"id\"(STRING), \"period_start\"(DATETIME)\r\n    *   \"Condition\": \"id\"(STRING), \"code_text\"(STRING)\r\n    *   \"Observation\": \"id\"(STRING), \"code_text\"(STRING), \"value\"(STRING)\r\n    *   \"Practitioner\": \"id\"(STRING), \"name\"(STRING)\r\n    *   \"MedicationRequest\": \"id\"(STRING), \"medication\"(STRING)\r\n*   **Relationships:**\r\n    *   \"(:Patient)-[:HAS_CONDITION]->(:Condition)\"\r\n    *   \"(:Patient)-[:HAD_ENCOUNTER]->(:Encounter)\"\r\n    *   \"(:Patient)-[:PRESCRIBED_MEDICATION]->(:MedicationRequest)\"\r\n    *   \"(:Encounter)-[:ATTENDED_BY]->(:Practitioner)\"\r\n    *   \"(:Condition)-[:DIAGNOSED_DURING]->(:Encounter)\"\r\n    *   \"(:Observation)-[:MEASURED_DURING]->(:Encounter)\"\r\n\r\n---\r\n**2. Output Schema:**\r\n{\r\n  \"should_augment\": boolean,\r\n  \"suggested_cypher\": \"string or null\"\r\n}\r\n\r\n---\r\n**3. Examples:**\r\n\r\n**Example 1 (Augmentation Needed):**\r\n*   **User Query Summary:** \"Find the most common medication prescribed for 'Hypertension' by the practitioner named 'Dr. John Doe'.\"\r\n*   **Executed Cypher:**\r\n    \"\"\"cypher\r\n    MATCH (pr:Practitioner {name: 'Dr. John Doe'})<-[:ATTENDED_BY]-(e:Encounter)<-[:DIAGNOSED_DURING]-(c:Condition {code_text: 'Hypertension'}),\r\n          (p:Patient)-[:PRESCRIBED_MEDICATION]->(mr:MedicationRequest),\r\n          (p)-[:HAD_ENCOUNTER]->(e)\r\n    RETURN mr.medication AS Medication, count(mr) AS Frequency\r\n    ORDER BY Frequency DESC\r\n    LIMIT 5\r\n    \"\"\"\r\n*   **Your JSON Output:**\r\n    \"\"\"json\r\n    {\r\n      \"should_augment\": true,\r\n      \"suggested_cypher\": \"MATCH (c:Condition {code_text: 'Hypertension'})<-[:DIAGNOSED_DURING]-(e:Encounter), (p:Patient)-[:PRESCRIBED_MEDICATION]->(mr:MedicationRequest), (p)-[:HAD_ENCOUNTER]->(e) RETURN mr.medication AS Medication, count(mr) AS Frequency ORDER BY Frequency DESC LIMIT 5\"\r\n    }\r\n    \"\"\"\r\n\r\n**Example 2 (No Augmentation Needed):**\r\n*   **User Query Summary:** \"Find all conditions for the patient named 'Annamarie Hane'.\"\r\n*   **Executed Cypher:**\r\n    \"\"\"cypher\r\n    MATCH (p:Patient {name: 'Annamarie Hane'})-[:HAS_CONDITION]->(c:Condition) RETURN c.code_text AS Condition, c.onsetDateTime AS DiagnosisDate\r\n    \"\"\"\r\n*   **Your JSON Output:**\r\n    \"\"\"json\r\n    {\r\n      \"should_augment\": false,\r\n      \"suggested_cypher\": null\r\n    }\r\n    \"\"\"\r\n\r\n**Example 3 (Augmentation Needed - Statistical):**\r\n*   **User Query Summary:** \"Count the number of patients assigned to 'Dr. Jane Smith' who have the condition 'Diabetes'.\"\r\n*   **Executed Cypher:**\r\n    \"\"\"cypher\r\n    MATCH (pr:Practitioner {name: 'Dr. Jane Smith'})<-[:ATTENDED_BY]-(e)<-[:HAD_ENCOUNTER]-(p:Patient)-[:HAS_CONDITION]->(c:Condition {code_text: 'Diabetes'})\r\n    RETURN count(DISTINCT p) AS NumberOfPatients\r\n    \"\"\"\r\n*   **Your JSON Output:**\r\n    \"\"\"json\r\n    {\r\n      \"should_augment\": true,\r\n      \"suggested_cypher\": \"MATCH (p:Patient)-[:HAS_CONDITION]->(c:Condition {code_text: 'Diabetes'}) WITH count(DISTINCT p) AS DiabeticPatients MATCH (total_p:Patient) WITH DiabeticPatients, count(total_p) AS TotalPatients RETURN DiabeticPatients, TotalPatients, (toFloat(DiabeticPatients) \/ TotalPatients) * 100 AS Percentage\"\r\n    }\r\n    \"\"\"\r\n---\r\n**4. Task:**\r\nAnalyze the following inputs and generate your JSON response.\r\n\r\n**User Query Summary:** \" ${summarized_user_query} \"\r\n\r\n**Executed Cypher:**\r\n\"\"\"cypher\r\n ${executed_cypher}\r\n\"\"\"
  `
  if (input.qryGenerated) {
    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: metaAnalysisPrompt,
      config: {
        responseMimeType: "application/json",
        responseJsonSchema: {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "title": "Query Augmentation Suggestion",
          "description": "Defines the output for the meta-analysis prompt, which suggests whether a query could be augmented with broader data and provides a new Cypher query if so.",
          "type": "object",
          "properties": {
            "should_augment": {
              "description": "A boolean flag that is true if the analysis suggests the query would benefit from being compared against the entire dataset.",
              "type": "boolean"
            },
            "suggested_cypher": {
              "description": "If should_augment is true, this contains a new, complete Cypher query string for a broader, comparative analysis. If false, this is null.",
              "type": [
                "string",
                "null"
              ]
            }
          },
          "required": [
            "should_augment",
            "suggested_cypher"
          ],
          "additionalProperties": false
        }
      }
    });
    metaAnalysisResult.meta = JSON.parse(response.text)
  }

  console.log("Returning generated Cypher query:", JSON.stringify(metaAnalysisResult, null, 2));
  return metaAnalysisResult;
};

/**
 * Activity 4: Creates an audit log of the operation.
 * It receives the output from the `generateCypher` activity.
 */
const createAuditLog = async (ctx, input) => {
  console.log("\n--- Activity: createAuditLog ---");
  console.log("Received input for auditing:", JSON.stringify(input, null, 2));

  // TODO: Add your logic to save the audit trail to a database or logging service.
  // For example, log the original query, the generated Cypher, and timestamps.
  const auditId = `audit_${new Date().getTime()}`;
  console.log(`Audit log created with ID: ${auditId}`);

  // The result of this activity includes all previous data plus the audit confirmation.
  const finalResult = {
    ...input, // Pass through all previous data
    auditId: auditId,
    auditedAt: new Date().toISOString(),
    status: "SUCCESS",
  };

  console.log("Returning final result:", JSON.stringify(finalResult, null, 2));
  return finalResult;
};


// --- WORKFLOW ---
// The workflow defines the order and logic of the activity calls.

/**
 * The main workflow orchestrator.
 * It calls the activities in sequence, passing data between them.
 */
const aiCypherQueryGeneratorWorkflow = async function* (ctx, input) {
  const instanceId = ctx.instance_id;
  console.log(`\n>>> Starting workflow '${ctx.workflow_name}' with instance ID: ${instanceId}`);
  console.log(`>>> Initial payload: ${JSON.stringify(input)}`);

  try {
    // Step 1: Call the validation activity
    const validationResult = yield ctx.callActivity(validateQuery, input);

    // Step 2: Call the Cypher generation activity, passing the result from step 1
    const cypherResult = yield ctx.callActivity(generateCypher, validationResult);

    // Step 2: Call the Cypher generation activity, passing the result from step 1
    const metaAnalysisResult = yield ctx.callActivity(metaAnalysis, cypherResult);

    // Step 4: Call the audit log activity, passing the result from step 2
    const auditResult = yield ctx.callActivity(createAuditLog, metaAnalysisResult);

    console.log(`\n>>> Workflow finished successfully for instance ID: ${instanceId}`);

    // The final result of the workflow execution
    return {
      processed: true,
      ...auditResult,
    };
  } catch (error) {
    console.error(`\nXXX Workflow failed for instance ID: ${instanceId}`, error);

    // You can add a compensating activity here, like sending a failure notification.

    return { processed: false, error: error.message };
  }
};

// Export the workflow and all activities so the Dapr runtime can register them.
export {
  aiCypherQueryGeneratorWorkflow,
  validateQuery,
  generateCypher,
  createAuditLog,
  metaAnalysis
};